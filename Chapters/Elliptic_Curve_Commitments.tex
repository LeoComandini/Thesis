\chapter{Elliptic Curve Commitments}
\label{chpr:ec-commitments}
Elliptic Curve Cryptography is used in Bitcoin and in similar systems to secure the transactions. 
We will give a brief overview of this cryptosystem, then we show how a elliptic curve points can be a commitment, finally we describe the consequent practical timestamping applications with Bitcoin.  

\section{Elliptic Curve Public Key Cryptosystem}
We start with a general definition taken from \cite{Koblitz1987}\footnote{see Appendix \ref{app:A} for a more basic approach.},
\begin{mydef}
	An elliptic curve $E_K$ defined over a field $K$ of characteristic $\neq 2, 3$ is the set of solutions $(x,y)\in K^2$ to the equation
	\begin{equation}
	\label{ec-eq}
	y^2 = x^3 + ax + b, \quad a,b \in K
	\end{equation}
	together with a "point at infinity" $\mathcal{O}$.
\end{mydef}
$\mathcal{O}$ is the projective closure of (\ref{ec-eq}) and may not be described in terms of two coordinates in $K$.
The points on $E_K$ form a group with identity element the point at infinity. The negative point $P \in E_K$ is the second point on $E_K$ having the same $x$-coordinate as $P$. Let $P_1=(x_1,y_1)$ and $P_2=(x_2,y_2)$ be two points on the curve, their sum $P_3=(x_3,y_3) = P_1 + P_2$ is given by:
\begin{equation}
x_3 = -x_1 -x_2 + \alpha^2, \quad 
y_3 = -y_1 + \alpha(x_1 - x_3),
\end{equation}
where
\begin{equation}
\alpha = \begin{cases}
			(y_2 - y_1)/(x_2 - x_1) & \textrm{if } P_1 \neq P_2, \\
			(3x_1^2 + a)/(2y_1) & \textrm{if } P_1 = P_2.
\end{cases}
\end{equation}
This \textit{addition} operation for elliptic curve points has a geometric interpretation for $K = \mathbb{R}$, from which the above more general algebraic formulae can be derived.

Using these formulae, one can compute a multiple $mP$ of a given point $P$ in polynomial time by means of $O(\log m)$ doubling and additions, e.g. $11P = P + 2(P + 2(2P))$. This operation is called \textit{scalar multiplication}.

In cryptography most applications use finite fields, in particular a finite field contains $p^m$ elements with $p$ prime and $m \geq 1$. We will confine ourselves to the case $m=1$. So let $K=GF(p)=\mathbb{F}_p =\mathbb{Z}_p  = \{0, 1, ..., p-1\}$, $K$ is a finite field, the points of $E_K$, toghether with the addition operation defined above, form a finite Abelian group. The ellptic curve becomes:
%cyclic or product of two cyclic groups
\begin{equation}
E_{\mathbb{F}_p}=\{(x,y)\in \mathbb{F}_p^2 \quad \textmd{s.t. }
y^2 = x^3 + ax + b \mod p, \quad a,b \in \mathbb{F}_p \} \cup \mathcal{O}
\end{equation}
Let $G \in E_{\mathbb{F}_p}$ be a conventional element of order $n$, called $generator$. The subgroup generated by $G$ is:
\begin{equation}
	\langle G \rangle = \{xG|x \in \mathbb{Z}_n\} \subseteq E_{\mathbb{F}_p}
\end{equation}
Which is a cyclic group isomorphic to $\mathbb{Z}_n$; in particular, if $n$ is prime, then $\langle G \rangle = E_{\mathbb{F}_p}$.

Computing the isomorphism from $\mathbb{Z}_n$ to $\langle G \rangle$ is efficient, it takes $O(\log n)$ group operations; while the opposite isomorphism is much harder to compute, at moment, the best algorithm known takes approximately $\sqrt{n}$ operations. The latter procedure is called discrete logarithm and it stands at the base of the cryptosystem, more precisely:
\begin{mydef}
	Elliptic Curve Discrete Logarithm Problem (ECDLP). Given an elliptic curve $E$ defined over $GF(q)$ and two points $P, Q \in E$, find an integer $x$ such that $Q = xP$ if such $x$ exists.
\end{mydef}
Elliptic curve cryptography is based on the premise that ECDLP is hard, actually it appears to be more intractable than DLP in finite fields.
The ECDLP difficulty enables a Diffie-Hellmann key exchange which precedes the ElGamal signature scheme, these techniques are at the foundations of the public key cryptosystem.
Fixed a point $P \in E_{\mathbb{F}_p}$, a \textit{public key} is a point $Q \in E_{\mathbb{F}_p}$ while its discrete logatithm $x$ w.r.t. $P$ ($xP=Q$) is the \textit{private key}.
Given $x$ is easy and fast to compute $Q$, while given $Q$ is unfeasible to find $x$.

To classify different curves the Standard for Efficient Cryptography (SEC) proposed a set of parameter for elliptic curves over $\mathbb{F}_p$:
\begin{equation}
(p, a, b, G, n, h)
\end{equation}
\begin{itemize}
	\item $p$ prime defines the finite field $\mathbb{F}_p$
	\item $a, b \in \mathbb{F}_p$ define the curve $E_{\mathbb{F}_p}$
	\item $G\in E_{\mathbb{F}_p}\backslash \{\mathcal{O}\}$ is a generator of the group
	\item $n = |\langle G \rangle|$ is the order of the group (smallest $n>0$ s.t. $nG = \mathcal{O}$)
	\item $h = |E_{\mathbb{F}_p}| / n$ is the cofactor
\end{itemize}
Note that if $n$ prime, then $\langle G \rangle = E_{\mathbb{F}_p}$, thus $n = |E_{\mathbb{F}_p}|$, $h=1$.
Bitcoin uses the curve named $secp256k1$ with parameters
\begin{verbatim}
p = 0x FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 
       FFFFFFFE FFFFFC2F
a = 0
b = 7
G = (0x 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 
        59F2815B 16F81798, 
     0x 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 
        9C47D08F FB10D4B8)
n = 0x FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B 
       BFD25E8C D0364141
h = 1
\end{verbatim}
With this curve some calculation becomes more efficient, like computing the modular square root ($\sqrt{x}=x^{\lfloor\frac{p+1}{4}\rfloor}\textmd{ mod }p$) and the modular inverse ($x^{-1}=x^{p-2}\textmd{ mod }p$).

Looking at the generator above one may think that to store an elliptic curve point is necessary to use 32 bytes for the $x$-coordinate and 32 bytes for the $y$-coordinate. 
However it is not necessary to use all that space, infact it is possible to take advantage of the elliptic curve equation. Suppose $x \in \mathbb{F}_p$ is the $x$-coordinate of a point, then $y$ is given by $y^2 = x^3 + ax + b \quad \text{mod }n$, which, for $n$ prime, has exactly two solutions in $\mathbb{F}_p$, $y$ and $n-y$, one is odd and the other is even.
The solutions are easily computable thanks to the above formula.
Having consider this, to store an elliptic curve point $P$ one can store $P_x$ and the parity of $P_y$. 
In Bitcoin the compressed encoding of a point $P$ is given by a byte for the parity of $P_y$ ($02$ if even, $03$ if odd) followed by the bytes representing $P_x$, for instance the generator $G$ is encoded as follows:
\begin{verbatim}
G = 02 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 
       59F2815B 16F81798
\end{verbatim}

\section{A New Commitment Operation}

Combining conveniently elliptic curve points and hash functions is possible to create new commitment operations.
A similar technique was used for the first time for deriving public keys in deterministic wallets \cite{Max11},
then the concept of embedding a value in a elliptic curve point was exploited \cite{journals/corr/abs-1212-3257, Sidechain},
later it was reformulated in a more refined way \cite{PoePR, PoeIs}
suitable for the integration in OpenTimestamps.
Let's analyse how this new commitment operations are structured.

\begin{myprop}
	Let $E_{\mathbb{F}_p}$ be an elliptic curve defined on the finite field $\mathbb{F}_p$ with $p$ prime, $G \in E_{F_p}$ be the generator of the curve with order $n$ large prime. Let $h$ be a second-preimage resistant hash function, its input are somehow serialized in bits, its output are in $\{0,1\}^k$ and are interpreted as integers.
	Let $C$ be defined as follows:
	\begin{equation}
	\begin{split}
	C : \{0,1\}^* \times E_{\mathbb{F}_p}  & \rightarrow E_{\mathbb{F}_p} \\
	    m, P & \mapsto h(P||m)G + P
	\end{split}
	\end{equation}
	If $n$ is close to $2^k$, then $C$ is a commitment operation.
\end{myprop}
\begin{proof}
	First we show a direct proof that works when $P$ (or $P'$) is fixed then we show the general proof.
	\\
	Let $C(m,P)$ be a commitment to $m, P$.
	$\forall P' \in E_{\mathbb{F}_p}$ the problem is to find $m' \in \{0,1\}^*$ s.t. $C(m,P)=C(m',P')$ and $(m', P') \neq (m, P)$. We want to show that such problem is unfeasible.
	The substitute value $m'$ needs to satisfy $h(m'||P')G + P'=C(m,P)$.
	Let $x$ be such that $xG = C(m,P) - P'$, with $0\leq x<n$. 
	%so $x=h(P'||m')\textmd{ mod }n$. The problem to find a second preimage $m'$ of $x$.
	Define $h_{P'}$ as follows:
	\begin{equation}
	\begin{split}
	h_{P'}:\{0,1\}^* & \rightarrow \{0,1\}^k\\
	m' & \mapsto h(m'||P')
	\end{split}
	\end{equation}
	Let $I_x=\{h \in \{0,1\}^k \approx \mathbb{Z}_{2^k} | h=x\textmd{ mod }n\}$ be the set of images of $h_{P'}$ suitable to find a second-preimage.
	$I_x$ contains  $\lceil\frac{2^k}{n}\rceil$ or $\lfloor\frac{2^k}{n}\rfloor$ elements.
	Hence to find a second-preimage one needs to find $m'$ s.t. $h_{P'}(m') \in I_x$. Note that $h_{P'}$ is second-preimage resistant, since it is the composition of two function with that property, $prepend(P')$ and $h$. Finally, if $n \approx 2^k$, the elements in $I_x$ are few (eventually a single one), thus finding $m'$ is unfeasible because $h_{P'}$ is second-preimage resistant.
	\\
	Now consider the case in which $P$ is not fixed.
	Suppose we are able to find $x$ s.t. $P=xG$, the map $C$ can be seen as $m,x \mapsto x + h(xG||m)$ which is basically $m,x \mapsto x + \tilde{h}(x,m)$ for an opportune $\tilde{h}$.
	If such map is a random oracle then we are done, since random oracles are second preimage resistant.
	We assume $h$ is a random oracle, then also $\tilde{h}$ has the same feature, since it is independent from its input, moreover the offset $x$ does not affect the property. 
	Hence we conclude that the map is a random oracle which gives second preimage resistance.
\end{proof}

The order $n$ has to be large so that $E_{\mathbb{F}_p}$ is rich enough to make the ECDLP intractable and to avoid shrinking the hash function codomain. Fixed $n$ the choice of $k$ should be made properly: if it is too low $h$ will be too weak, if it is too high, $|I_x|$ will increase, weakening $C$. Hence a good compromise is choosing $n$ the closest possible.

The security of the commitment is given by the security of the hash function, and does not rely on the intractability of the ECDLP. Being able to compute the private key from the commitment is not enough to compute a second input committing to the same point, to do so is necessary to able to invert the hash function.

With this commitment an elliptic curve point used for one purpose can be tweaked and, while still serving for the previous purpose, it can be a commitment to a value $m$. In fact suppose $x$ is the private key of $P$, $P=xG$, then $C(m,P)=(h(P||m)+x)G$. So the new private key is $(h(P||m)+x) (\textmd{mod } n)$ and, since $x$ is secret and $h(P||m)$ is a constant value, the resulting key is still secret.
So each time a elliptic curve point is written, we can encapsulate in it a commitment to an arbitrary value.
This technique may be extended to more general cases, but we will treat only the case of elliptic curves.

Several hash functions and elliptic curves can be used, since we want to construct a working application on Bitcoin we will focus an a particular case with $h=$ SHA256 and $E_{\mathbb{F}_p}=secp256k1$ since Bitcoin itself relies on the assumption that this hash function and this elliptic curve are not broken, moreover the order of the curve $n$ is extremely close\footnote{The set of suitable images has cardinality 1 or 2, particularly the probability to choose an element with 2 possible images $1-\frac{n}{2^{256}}\approx10^{-33}$ which is almost zero.} 
to the cardinality of the hash function codomain $2^{256}$. This commitment operation is called \verb|OpSecp256k1Commitment|.

Moreover to use the operation in a OpenTimestamp receipt it has to be an unary operation, hence it will take as input $P||m$ and will return the $x$-coordinate as output, both in bytes. More precisely it will operate as described in Algorithm \ref{alg:opsecp256k1}.
\begin{algorithm}
	\caption{Commitment to a $secp256k1$ point using SHA256}
	\label{alg:opsecp256k1}
	\begin{algorithmic}[1]
	\Procedure{OpSecp256k1Commitment}{$c$}\Comment{$c$ is $P||m$}
	\State $P,m \gets$ \Call{decode}{$c$}\Comment{for bad $c$  return error}
	\State $tweak \gets h(P||m)$\Comment{interpreted as an int}
	\State $Q \gets tweak G + P$
	\State \textbf{return} \Call{encode}{$Q_x$}\Comment{output in bytes}
	\EndProcedure
	\end{algorithmic}
\end{algorithm}
It can be used for several purposes, however, for this work, we focus only on timestamping.

\section{Timestamping Applications}
On the Bitcoin chain, elliptic curve points are used as public keys locking bictoins or as part of the signature. The first case lead to the \textit{pay-to-contract} technique, the second to \textit{sign-to-contract}. We will analyse both uses and we will explain which one should be preferred.

This names owe their origin to the first application for which they were though, that was associating a \textit{contract} to an elliptic point. 
The term contract may seem misleading, but it turns out to be useful dealing with \textit{sign-to-contract}, since it let us distinguish between the message signed and the contract committed.

\subsection{\textit{pay-to-contract}}
Public keys are elliptic curve points, here we show how they could commit to a value while still maintaining the secrecy of the private key.

Alice needs to send Bob some bitcoins. Bob has public key $P=xG$. Bob wants to timestamp the message $m$. Bob computes $Q=h(P||m)G+P$. Bob tells Alice that his private key is $Q$. Alice broadcasts a transaction sending bitcoins to $Q$, for instance she uses a P2PK publishing on the chain:
\begin{verbatim}
script pubkey:
<Q> OP_CHECKSIG
\end{verbatim}
Bob can spend the bitcoin locked in this script because he knows $P$, $m$ and $x$, so he can compute the private key corresponding to $Q$, that is $(h(P||m)+x) \textmd{ mod } n$.
To create the timestamp proof he has to decompose the transaction including $Q$ and create a proof that will look like:
\begin{verbatim}
prepend P
secp256k1commitment
prepend TX_p
append TX_a
sha256
...
sha256
verify BitcoinBlockHeaderAttestation(block)
\end{verbatim} 
In the case of P2PKH, the committed public key is hashed as shown in the following real example, where \verb|b'Pay to contract!'| is timestamped: 
\begin{Verbatim}[frame=single]
File sha256: 47257ff8c07f55a2e697ab9d89e47b471f60ab3f6883ed05
             44561b2a39a26140
Timestamp:
prepend 02a1e5aafa5082d035c659143660b2526a4ba60d4ab5b2e603905
        0eae9444d56ee
secp256k1commitment
prepend 02
sha256
ripemd160
prepend 01000000018fccf63afda6cf748acfe946a344f417bd4a8994bc1
        bf933501a87986363464c000000006a47304402207724a6a96e91
        a10821ee0c6db30a2f764ba8bd1dcdc82812fb958f6b91e97a4a0
        22062db4df7205e6c97d9833f7ab0d597b7685e8320bb2031f57a
        a6981cd2f626a40121030eb7a6c01ab07d3bfe598c295e9edfbeb
        38e5d2df7320f16b4349fb89a975ab7fdffffff02e22000000000
        00001976a914d8da7633fe644eb12617b2b1f0ba3f0461a2bc5e8
        8ac10270000000000001976a914
append 88ac4ed90700
# Bitcoin transaction id
1b07d87e0f4e32d545932bf03e306d1532bc7d91f56e81dee81b7cd0b707a9
9d
sha256
sha256
prepend 9d12daa914a3d39cd25b36516383683aae3ac6f873b952bbab11cc
        417650bb49
sha256
sha256
prepend 0123f36690131b2416d32a7e6c3c63110d9d77873911f71ad22740
        b398a13874
sha256
sha256
append 9f45bbc92ac4ef65b5e5bfad479da46c400f6e7ab96217a20b4e08d
       bfab47a45
sha256
sha256
prepend 949c83f6b502ec75c4647da6ed4e26d181de07b325eac75881de7b
        b715a44c50
sha256
sha256
prepend 2ef8ff1aad05e891215698fe237546c73347967419f33d08baf0d9
        71ab00004d
sha256
sha256
append 9bf69359a440f6a15a2a11adb1f257c96089ad27ef66e57a19056e3
       3ecc1795b
sha256
sha256
prepend c1c9bb36792745df3967704dd5d15899bab47b0a9de35486eb339a
        b4d00ff340
sha256
sha256
append c0b13e8aa4dc85a8256efb03272dea659e41fc67bc2f44add154111
       c68f700be
sha256
sha256
append 1bf843d12afce2a7b02ebe1f083eb2c39a101a63474a622724f609a
       3f08f8c7f
sha256
sha256
append a29eece3554c358e5df3901478c8670c71dbafe4e435cf660a18bb6
       09d6d025d
sha256
sha256
append aa2c4696c3b75f73713345a7e4279805a9519fd067835769b41dcf7
       88d6a7c96
sha256
sha256
prepend f7290a75923a0c54e87a50bbeff75f614437ed799347a46053a633
        8dba42b5c7
sha256
sha256
verify BitcoinBlockHeaderAttestation(514394)
# Bitcoin block merkle root
be6859c5093de84a06e495b6621054616ce5bf7a38f24374a225d0da0c0de8
88
\end{Verbatim} 
The raw transaction with the above TXID is 
\begin{Verbatim}[commandchars=+\[\], frame=single]
01000000018fccf63afda6cf748acfe946a344f417bd4a8994bc1bf933501a
87986363464c000000006a47304402207724a6a96e91a10821ee0c6db30a2f
764ba8bd1dcdc82812fb958f6b91e97a4a022062db4df7205e6c97d9833f7a
b0d597b7685e8320bb2031f57aa6981cd2f626a40121030eb7a6c01ab07d3b
fe598c295e9edfbeb38e5d2df7320f16b4349fb89a975ab7fdffffff02e220
0000000000001976a914d8da7633fe644eb12617b2b1f0ba3f0461a2bc5e88
ac10270000000000001976a914+underline[57529515dc2e14701374eb65f0191b61ecfd]
+underline[d0e3]88ac4ed90700
\end{Verbatim}
Where the commitment to the data is underlined.

This technique is completely viable but on the other hand it has a relevant issue.
Almost all bitcoin wallet (software to manage private keys) use a deterministic derivation for creating new keys \cite{BIP32}. An initial value is generated at random using a cryptographically secure procedure, this value is called \textit{seed} and sometimes is a list of words from a given dictionary. The keys are obtained from the seed using the specifications given by BIP32 and they are something like $h(seed||number)$. This procedure make possible to completely recover a wallet from the seed only, so if a user wants to use his wallet from another device he just need to remember the seed and all his private keys will be reconstructed.
Using pay-to-contract actually Bob goes outside of the BIP32 derivation. So if he looses $m$ or $P$ he won't be able to spend the bitcoin locked by $Q$. For this reason the use of \textit{pay-to-contract} for mere timestamping purposes should be limited.

\subsection{\textit{sign-to-contract}}
The other place where elliptic curve points are published in the chain is the signature. Bitcoin uses the elliptic curve digital signature algorithm, ECDSA\footnote{\textit{sign-to-contract} works also with other signature schemes involving elliptic curves, like Schnorr signature.}, that works as detailed in Algorithm \ref{alg:ecdsa-sign}.
\begin{algorithm}
	\caption{ECDSA signature}
	\label{alg:ecdsa-sign}
	\begin{algorithmic}[1]
		\Procedure{ECDSAsig}{$x, m$}\Comment{$x$ private key signing}
		\Statex \Comment{$m$ 32 bytes message to be singed}
		\State $k \in_R \mathbb{F}_n \backslash \{0\}$ \Comment{select $k$ at random in $\{1,..., n-1\}$}
		\State $R \gets k G$
		\State $r \gets R_x \textmd{ mod }n$\Comment{if $r=0$, fail}
		\State $s \gets k^{-1}(m + rx) \textmd{ mod }n$\Comment{if $s=0$, fail}
		\State \textbf{return} $(r,s)$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
The value $k$ is called nonce or \textit{ephemeral private key}, $R$ is called \textit{ephemeral public key}.
Its a common practice to avoid to generate $k$ at random,  instead is performed a deterministic derivation of the type $k \gets h(x||m)$, the precise specification of $h$ is given by the RFC6979 standard \cite{rfc6979}.

A signature is a couple of integer in $\{1,...,n-1\}$, the first one is the $x$-coordinate (mod $n$) of the ephemeral public key.
The idea of \textit{sign-to-contract}, exploited in Algorithm \ref{alg:ecdsa-s2c}, is to tweak $R$, so that the first part of the signature will be a commitment to (also) another message, the contract $c$.
\begin{algorithm}
	\caption{ECDSA \textit{sign-to-contract} (s2c)}
	\label{alg:ecdsa-s2c}
	\begin{algorithmic}[1]
		\Procedure{ECDSAs2c}{$x, m, c$}\Comment{$x$ private key}
		\Statex \Comment{$m$ 32 bytes message to be singed}
		\Statex \Comment{$c$ contract to commit}
		\State $k \gets$ \Call{DeterministicNonce}{$x,m$} \Comment{using RFC6979}
		\State $R \gets k G$
		\State $tweak \gets h(R||c)$\Comment{interpreted as an int}
		\State $e \gets (k + tweak) \textmd{ mod }n$ \Comment{if $e=0$, fail}
		\State $Q \gets tweak G + R$
		\State $q \gets Q_x \textmd{ mod }n$\Comment{if $q=0$, fail}
		\Statex \Comment{if $q \neq Q_x$, commitment fail}
		\State $s \gets e^{-1}(m + qx) \textmd{ mod }n$\Comment{if $s=0$, fail}
		\State \textbf{return} $(q,s), R$\Comment{$R$ is needed to prove the commitment}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Let's examine a real timestamp for the data \verb|b'Sign to contract'| made with the described technique.
\begin{Verbatim}[frame=single]
File sha256: dd60bcfecd023823efdcb8d8a5b04939111ef82dc1d674320
             7e164e5aab08844
Timestamp:
append eb7e45e783d98504b2e64342b0bea3f5
sha256
prepend 0372a1fb359a24eab552e8c588f84b7e08144bbb10e87bfa6db649
        8c7df730e867
secp256k1commitment
prepend 01000000018fccf63afda6cf748acfe946a344f417bd4a8994bc1b
        f933501a87986363464c010000006a4730440220
append 022057db028ba602b467d09f67b6a6327d3219f2d9a264aae935873
       146247a18008a0121027f4b59c84fbad07dec6cff8555214b1d3740
       43bcdf47a35fbe08cf5a816b2a9ffdffffff02a6220000000000001
       976a914c7a270de581a188f1decef735602cfd65a70607c88ac1027
       0000000000001976a914ebc32f6f0a4d63da2d1a2f1f5cb762d0d89
       824d488acf3d90700       
# Bitcoin transaction id 
3b6b0f10729cd0d90087e8c8c9261a2b41afa4e26508591700ddd1790b5087
05
sha256
sha256
append 8c6c3e7341ac6b64c17e4558a5279da1ccf5a0346abbcb1eed412db
       103ff7cb5
sha256
sha256
prepend 8446d10571b0a6c63a0fb9538531d846148c9465eff456cccbaf91
        1a967bc74c
sha256
sha256
prepend 66cdb8cf28763b45e195028566a0bd976afcf7ad072188e711e515
        41f6867e43
sha256
sha256
prepend 465585e6b3ff7dfc8d753acce6e60c1ccd246975641dd4ad8b95c3
        803244aca7
sha256
sha256
append 93bcaa3a00534081d6f2230412cde7e59a73acb0d98c809174f630d
       e3b07b89d
sha256
sha256
append 0f1b327e68d8700e9c4074d8b4b82b0e28a5a7933f29f643cb27bd5
       6bf668ec6
sha256
sha256
append d8738b3726def527296f47a70e0ba6841e35932e2ac8a0832c25393
       ee320d4fc
sha256
sha256
append 73694be809a1f8d8a81f55e812c47d388747e1d99003d5b5427ca41
       1a5fd4408
sha256
sha256
append 816fb904a9d0678198e84f060aecca9383320bebfec2d23783c922b
       cdcb58af2
sha256
sha256
prepend f42214bc9a9c8e4b61a53e51c94ef9bbb2956202356054cd7a7677
        858caae2de
sha256
sha256
prepend 1d71d75ef769c40aec08c7ccda1a64a82ee6e858efb5f8598f5199
        a093b512d1
sha256
sha256
append 00b4475e869c96c8c297fce9ea8494f0b8f5c74d7b4e6208ba8fc84
       d103f61d2
sha256
sha256
verify BitcoinBlockHeaderAttestation(514550)
# Bitcoin block merkle root 
1d978e90baecf86c9b59ecad7d8e635da27aad41b39a1d4452c7654f9d5cd3
dd
\end{Verbatim}
The raw transaction with the above TXID is 
\begin{Verbatim}[commandchars=+\[\], frame=single]
01000000018fccf63afda6cf748acfe946a344f417bd4a8994bc1bf933501a
87986363464c010000006a4730440220+underline[280686720849bfd72a3c7793a45610]
+underline[db2f0152422183bb1f7181ca003674aea5]022057db028ba602b467d09f67b6
a6327d3219f2d9a264aae935873146247a18008a0121027f4b59c84fbad07d
ec6cff8555214b1d374043bcdf47a35fbe08cf5a816b2a9ffdffffff02a622
0000000000001976a914c7a270de581a188f1decef735602cfd65a70607c88
ac10270000000000001976a914ebc32f6f0a4d63da2d1a2f1f5cb762d0d898
24d488acf3d90700
\end{Verbatim}
Where the commitment value is underlined.

Using \textit{sign-to-contract} every signature can include a commitment to a certain value. Contrary to \textit{pay-to-contract}, the loss of $c$ or $R$ leads to the impossibility of proving the commitment but not to a loss of funds. Indeed the signature published on the chain has already provided to its original purpose moving the coins to another owner. This makes \textit{sign-to-contract} a preferable commitment scheme.

The technique behind \textit{sign-to-contract} can be seen as a use of the subliminal channel in the ECDSA signature, exploited in \cite{DBLP:journals/jsac/Simmons98}. 
For a fixed message $m$ and fixed private key $x$, selecting $k$ at random gives the signer some arbitrariness on how the signature will look like. 
Consider the case where Alice want to secretly communicate a simple message $c$ to Bob. Alice produces a signature which is a commitment via \textit{sign-to-contract} to a simple message $c$. Alice declares $P$ publicly. Bob knows that $c$ comes from a brute forceable set $S$. Bob sees the signature and tries all $c \in S$ until he finds the one which generated the commitment. So Alice sent to Bob a message without anyone noticing the communication using the subliminal channel that ECDSA leaves open.